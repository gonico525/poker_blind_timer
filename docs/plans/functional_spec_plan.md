# 機能仕様書作成計画書

## 1. 計画書の概要

### 1.1 目的
要求仕様書（docs/urs/requirements.md v1.1）に基づき、実装可能な詳細レベルの機能仕様書を作成するための計画を策定する。

### 1.2 対象ドキュメント
- **作成物**: 機能仕様書（docs/specs/functional_specification.md）
- **参照元**: 要求仕様書（docs/urs/requirements.md）

### 1.3 期待される成果物
開発者が実装を開始できる具体的で詳細な仕様書。以下を含む：
- 技術スタックとアーキテクチャ
- データモデルとスキーマ
- UI/UXの詳細仕様
- API仕様（内部モジュール間）
- 状態管理の設計
- エラーハンドリング戦略

---

## 2. 機能仕様書の構成計画

### 2.1 作成する機能仕様書のセクション

#### セクション1: システム概要
- システムアーキテクチャ図
- 技術スタック詳細
- ディレクトリ構成
- 依存関係とバージョン

#### セクション2: 技術設計
- **2.1 アーキテクチャパターン**
  - レイヤー構造（Domain / UI / Services / Utils）
  - 状態管理戦略（React Context / Zustand / Redux Toolkit等の選定）
  - イベント駆動アーキテクチャ

- **2.2 ドメインモデル設計**
  - Tournament（トーナメント）
  - BlindLevel（ブラインドレベル）
  - Timer（タイマー）
  - Preset（プリセット）
  - BreakConfig（休憩設定）
  - TournamentConfig（トーナメント設定）

- **2.3 データフロー図**
  - ユーザー操作 → 状態更新 → UI再レンダリング
  - タイマーイベント → 状態更新 → 音声通知
  - データ永続化フロー

#### セクション3: データモデル仕様

- **3.1 TypeScript型定義**
  - すべてのドメインモデルの詳細型定義
  - インターフェース設計

- **3.2 localStorage スキーマ**
  - プリセットデータ構造
  - 設定データ構造
  - キー命名規則
  - バージョニング戦略

- **3.3 デフォルトデータ**
  - デフォルトプリセット（スタンダード、ターボ、ディープスタック）
  - デフォルト設定値

#### セクション4: UI/UX詳細仕様

- **4.1 画面仕様**
  - メイン画面（タイマー表示）のワイヤーフレーム
  - 設定画面のワイヤーフレーム
  - プリセット管理画面のワイヤーフレーム
  - 休憩中画面のワイヤーフレーム

- **4.2 コンポーネント設計**
  - コンポーネントツリー
  - 各コンポーネントのProps定義
  - 責務分担

- **4.3 デザインシステム**
  - カラーパレット（ダークモード/ライトモード）
  - タイポグラフィスケール
  - スペーシングシステム
  - ブレークポイント

- **4.4 アニメーション仕様**
  - レベル変更時のトランジション
  - タイマーカウントダウンのアニメーション
  - 休憩開始時の視覚効果

#### セクション5: 機能詳細仕様

- **5.1 タイマー機能**
  - タイマー実装方式（setInterval vs requestAnimationFrame）
  - 精度保証の仕組み
  - バックグラウンドタブでの動作
  - 状態遷移図

- **5.2 ブラインド管理機能**
  - レベル進行ロジック
  - 休憩挿入ロジック
  - 手動レベル変更のバリデーション

- **5.3 プリセット管理機能**
  - CRUD操作の詳細
  - インポート/エクスポートフォーマット
  - データバリデーションルール

- **5.4 音声通知機能**
  - 音声ファイルの管理方法
  - 再生タイミング
  - 音量制御の実装

- **5.5 キーボードショートカット**
  - イベントリスナーの実装方式
  - キーバインディング一覧
  - フォーカス管理

- **5.6 フルスクリーン機能**
  - Fullscreen API の使用
  - ブラウザ互換性対応
  - フォールバック戦略

#### セクション6: 状態管理仕様

- **6.1 グローバル状態**
  - Tournament状態
  - Timer状態
  - Settings状態
  - UI状態（モーダル、テーマなど）

- **6.2 状態遷移**
  - タイマーの状態遷移図（停止 → 開始 → 一時停止 → 再開）
  - レベル遷移の状態図（通常レベル ⇄ 休憩）

- **6.3 副作用管理**
  - localStorage への保存タイミング
  - 音声再生のトリガー
  - タイマーのライフサイクル

#### セクション7: エラーハンドリング

- **7.1 エラーカテゴリ**
  - ユーザー入力エラー
  - データ整合性エラー
  - ブラウザAPI失敗
  - localStorage容量超過

- **7.2 エラー表示戦略**
  - トースト通知
  - インラインエラーメッセージ
  - フォールバックUI

- **7.3 リカバリ戦略**
  - データ復元メカニズム
  - タイマー同期ずれの補正

#### セクション8: パフォーマンス最適化

- **8.1 レンダリング最適化**
  - React.memo の使用箇所
  - useCallback / useMemo の使用方針
  - 仮想化（必要に応じて）

- **8.2 バンドルサイズ最適化**
  - コード分割戦略
  - 遅延ロード
  - Tree shaking

- **8.3 タイマー精度**
  - Web Workers の検討
  - ドリフト補正アルゴリズム

#### セクション9: テスト戦略

- **9.1 単体テスト**
  - ドメインロジックのテスト
  - ユーティリティ関数のテスト

- **9.2 統合テスト**
  - コンポーネントテスト（React Testing Library）
  - フックテスト

- **9.3 E2Eテスト**
  - クリティカルパスのシナリオ
  - ブラウザ互換性テスト

#### セクション10: デプロイメント

- **10.1 ビルド設定**
  - Vite / Create React App / Next.js の選定
  - 環境変数
  - ビルド最適化

- **10.2 静的ホスティング**
  - GitHub Pages / Netlify / Verge等の選定
  - PWA対応の検討

---

## 3. 技術スタック詳細計画

### 3.1 推奨技術スタック

#### Option A: React + TypeScript + Vite ⭐ **推奨**

**理由**:
- TypeScript：型安全性、ドメインモデルの明確化
- React：宣言的UI、豊富なエコシステム
- Vite：高速な開発体験、軽量なビルド

**主要ライブラリ候補**:
```json
{
  "dependencies": {
    "react": "^18.x",
    "react-dom": "^18.x"
  },
  "devDependencies": {
    "typescript": "^5.x",
    "vite": "^5.x",
    "@vitejs/plugin-react": "^4.x"
  }
}
```

**状態管理**:
- 候補1: React Context + useReducer（シンプル、依存なし）⭐
- 候補2: Zustand（軽量、DevTools）
- 候補3: Redux Toolkit（過剰の可能性あり）

**スタイリング**:
- 候補1: CSS Modules（シンプル）⭐
- 候補2: Tailwind CSS（高速開発）
- 候補3: styled-components（CSS-in-JS）

#### Option B: バニラTS + Vite

**理由**:
- フレームワークなし、完全な制御
- 学習コスト低い
- 軽量

**推奨度**: ★★☆☆☆（小規模には良いが、拡張性を考えるとReactが有利）

### 3.2 選定基準

| 項目 | React + TS + Vite | バニラTS |
|------|------------------|----------|
| 開発速度 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| 型安全性 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 拡張性 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| バンドルサイズ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| 学習コスト | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

**最終推奨**: React + TypeScript + Vite

---

## 4. アーキテクチャ設計方針

### 4.1 ディレクトリ構成（案）

```
poker-blind-timer/
├── public/
│   ├── sounds/              # 音声ファイル
│   │   ├── level-change.mp3
│   │   ├── warning-1min.mp3
│   │   └── warning-30sec.mp3
│   └── favicon.ico
├── src/
│   ├── domain/              # ドメインロジック層
│   │   ├── models/
│   │   │   ├── Tournament.ts
│   │   │   ├── BlindLevel.ts
│   │   │   ├── Timer.ts
│   │   │   ├── Preset.ts
│   │   │   └── BreakConfig.ts
│   │   ├── events/
│   │   │   └── TournamentEvents.ts
│   │   └── index.ts
│   ├── services/            # アプリケーションサービス層
│   │   ├── storage/
│   │   │   ├── PresetStorage.ts
│   │   │   ├── SettingsStorage.ts
│   │   │   └── StorageService.ts
│   │   ├── audio/
│   │   │   └── AudioService.ts
│   │   ├── keyboard/
│   │   │   └── KeyboardService.ts
│   │   └── index.ts
│   ├── ui/                  # プレゼンテーション層
│   │   ├── components/
│   │   │   ├── timer/
│   │   │   │   ├── TimerDisplay.tsx
│   │   │   │   ├── BlindInfo.tsx
│   │   │   │   └── ControlButtons.tsx
│   │   │   ├── settings/
│   │   │   │   ├── SettingsPanel.tsx
│   │   │   │   ├── BlindEditor.tsx
│   │   │   │   ├── BreakSettings.tsx
│   │   │   │   └── ThemeToggle.tsx
│   │   │   ├── preset/
│   │   │   │   ├── PresetList.tsx
│   │   │   │   ├── PresetForm.tsx
│   │   │   │   └── ImportExport.tsx
│   │   │   ├── common/
│   │   │   │   ├── Button.tsx
│   │   │   │   ├── Modal.tsx
│   │   │   │   └── Input.tsx
│   │   │   └── layout/
│   │   │       ├── MainLayout.tsx
│   │   │       └── FullscreenLayout.tsx
│   │   ├── views/
│   │   │   ├── TimerView.tsx
│   │   │   ├── SettingsView.tsx
│   │   │   └── PresetView.tsx
│   │   ├── hooks/
│   │   │   ├── useTournament.ts
│   │   │   ├── useTimer.ts
│   │   │   ├── usePresets.ts
│   │   │   ├── useKeyboard.ts
│   │   │   └── useAudio.ts
│   │   └── styles/
│   │       ├── globals.css
│   │       ├── themes.css
│   │       └── variables.css
│   ├── utils/               # ユーティリティ
│   │   ├── timeFormat.ts
│   │   ├── validation.ts
│   │   └── constants.ts
│   ├── types/               # 型定義
│   │   ├── domain.ts
│   │   ├── storage.ts
│   │   └── ui.ts
│   ├── context/             # React Context（状態管理）
│   │   ├── TournamentContext.tsx
│   │   └── SettingsContext.tsx
│   ├── App.tsx
│   ├── main.tsx
│   └── vite-env.d.ts
├── tests/                   # テスト
│   ├── unit/
│   ├── integration/
│   └── e2e/
├── docs/
│   ├── urs/                 # 要求仕様書（既存）
│   ├── plans/               # 計画書（本ドキュメント）
│   └── specs/               # 機能仕様書（作成予定）
├── package.json
├── tsconfig.json
├── vite.config.ts
└── README.md
```

### 4.2 レイヤー間の依存関係

```
┌─────────────────────────────────────┐
│           UI Layer (React)           │
│  Components, Views, Hooks            │
└──────────────┬──────────────────────┘
               │ uses
               ↓
┌─────────────────────────────────────┐
│      Services Layer                  │
│  Storage, Audio, Keyboard            │
└──────────────┬──────────────────────┘
               │ uses
               ↓
┌─────────────────────────────────────┐
│      Domain Layer                    │
│  Tournament, Timer, BlindLevel       │
└─────────────────────────────────────┘
```

**依存関係ルール**:
- UI層 → Services層、Domain層を使用可
- Services層 → Domain層を使用可
- Domain層 → 他層に依存しない（純粋ロジック）

### 4.3 ドメインモデルの責務

#### Tournament クラス
- 現在のレベル管理
- レベル進行ロジック
- 休憩判定ロジック
- 次の休憩までの計算

#### Timer クラス
- カウントダウン機能
- 一時停止/再開
- リセット
- 時間精度保証

#### BlindLevel クラス（Value Object）
- SB/BB/アンティの値を保持
- イミュータブル
- バリデーション

#### Preset クラス
- プリセット情報（名前、レベル配列、設定）
- シリアライズ/デシリアライズ

---

## 5. データモデル設計方針

### 5.1 TypeScript型定義の設計方針

- **Strict モード**: 厳格な型チェック
- **Readonly**: イミュータブルなデータはReadonly型
- **Union Types**: 状態を型で表現（"idle" | "running" | "paused"）
- **Branded Types**: プリミティブ型の区別（LevelId, PresetIdなど）

### 5.2 localStorage スキーマ設計

**キー命名規則**:
- プレフィックス: `poker-timer:`
- 例: `poker-timer:presets`, `poker-timer:settings`

**バージョニング**:
- スキーマバージョンを含める
- マイグレーション戦略

### 5.3 デフォルトプリセットの定義

機能仕様書で具体的なブラインド構造を定義する必要があります（確認事項参照）。

---

## 6. UI/UX設計方針

### 6.1 デザインシステム

**カラーパレット**:
- ダークモード: ポーカーグリーン、ダークグレー、ゴールド
- ライトモード: ホワイト、ライトグレー、アクセント

**タイポグラフィ**:
- タイマー: 100px以上の大きなフォント
- ブラインド情報: 60-80px
- 補助情報: 20-30px

### 6.2 アニメーション方針

- レベル変更: フェードイン/スライドアニメーション
- タイマー終了: 点滅効果
- 休憩開始: 全画面トランジション

### 6.3 レスポンシブ対応

- 最小解像度: 1280x720px
- フルスクリーン最適化
- フォントサイズの動的調整（vw/vh単位）

---

## 7. 音声通知設計方針

### 7.1 音声ファイル管理

**選択肢**:
1. 既存の音源を使用（フリー素材）⭐
2. Web Audio API で生成（ビープ音）
3. Text-to-Speech API（ブラウザ対応）

### 7.2 再生タイミング

機能仕様書で具体的なタイミングを定義（確認事項参照）。

---

## 8. 確認事項・未決定項目

### 8.1 デフォルトプリセットの具体的構造

以下のプリセットの具体的なブラインド構造を決定する必要があります：

#### ❓ スタンダードトーナメント
- 開始ブラインド: 25/50? 50/100?
- レベル数: 10レベル
- 上昇率: 2倍? 1.5倍?
- 具体的な構造を確認したい

**例**:
```
Level 1: 25/50, Ante 0
Level 2: 50/100, Ante 0
Level 3: 75/150, Ante 25
Level 4: 100/200, Ante 25
...
```

#### ❓ ターボトーナメント
- スタンダードとの違いは？
- より急速なブラインド上昇?

#### ❓ ディープスタックトーナメント
- スタンダードとの違いは？
- より緩やかなブラインド上昇?

### 8.2 音声通知の詳細仕様

#### ❓ 警告音のタイミング
要求仕様書では「残り1分、30秒」とありますが、以下を確認：

- レベル終了前の警告音は何回鳴らす？
  - [ ] 残り5分
  - [ ] 残り3分
  - [ ] 残り1分（✓確定）
  - [ ] 残り30秒（✓確定）
  - [ ] 残り10秒
  - [ ] その他: ___________

- 休憩終了前の警告音は？
  - [ ] レベルと同じ
  - [ ] 異なる（どう異なる？）

#### ❓ 音声ファイルの種類
- レベル変更音: どんな音？（チャイム、ベル、ビープ等）
- 警告音: どんな音？（短いビープ、チック音等）
- 休憩開始音: 特別な音？

#### ❓ 音量調整の詳細度
- オン/オフのみ？
- 段階調整（0-100%）？
- 個別調整（レベル変更音と警告音を別々に）？

### 8.3 休憩設定のデフォルト値

#### ❓ デフォルトの休憩設定
- 休憩は何レベルごと？（4レベル? 5レベル?）
- 休憩時間のデフォルト値は？（10分? 15分?）
- 初期状態で休憩は有効/無効？

### 8.4 レベル時間のデフォルト値

#### ❓ デフォルトのレベル時間
要求仕様書では「初期値: 10分（調整可能）」とありますが：
- これでよい？
- プリセットごとに異なるデフォルト時間？
  - スタンダード: 15分?
  - ターボ: 10分?
  - ディープスタック: 20分?

### 8.5 フルスクリーンAPIの対応範囲

#### ❓ フォールバック戦略
- Fullscreen API非対応ブラウザでの挙動は？
  - 通常の最大化表示にフォールバック？
  - エラーメッセージ表示？
  - 機能を隠す？

### 8.6 localStorage容量制限への対応

#### ❓ プリセット数の上限
- 最大何個まで保存可能にする？（制限なし? 50個? 100個?）
- 上限に達した場合の挙動は？
  - エラー表示して保存拒否？
  - 古いものを削除？

### 8.7 データ検証とエラーハンドリング

#### ❓ インポートデータの検証
- 不正なJSON形式の場合？
- スキーマが一致しない場合？
- ブラインド値が異常（負の数、0等）な場合？

### 8.8 タイマー精度の要求レベル

#### ❓ 許容される誤差
- 1秒あたり何ミリ秒の誤差まで許容？
- バックグラウンドタブでの動作は？
  - 正確性優先（Web Workers使用）
  - パフォーマンス優先（setInterval使用）

### 8.9 キーボードショートカットの競合

#### ❓ 設定画面でのキーボードショートカット
- 入力フィールドにフォーカスがある時はショートカット無効？
- Escキーの優先順位（モーダルを閉じる vs フルスクリーン解除）は？

### 8.10 テーマの初期値

#### ❓ 初回起動時のテーマ
- ダークモード？
- ライトモード？
- システム設定に従う（prefers-color-scheme）？

### 8.11 アニメーション設定

#### ❓ アニメーション速度
- レベル変更のトランジション時間は？（0.3秒? 0.5秒? 1秒?）
- アニメーションON/OFFの設定は必要？（アクセシビリティ）

### 8.12 ブラウザ対応範囲

#### ❓ 最小サポートバージョン
- Chrome: v?
- Firefox: v?
- Safari: v?
- Edge: v?

具体的な対応範囲によって、ポリフィルが必要な機能が変わります。

---

## 9. 作業計画

### 9.1 機能仕様書作成のフェーズ

#### Phase 1: 確認事項の解決（本計画書）
- **成果物**: 確認事項への回答
- **所要時間**: ユーザーとのやり取り

#### Phase 2: 技術設計セクションの作成
- システムアーキテクチャ図
- ドメインモデル詳細設計
- データフロー図
- **所要時間**: 1-2時間相当

#### Phase 3: データモデル仕様の作成
- TypeScript型定義の詳細
- localStorage スキーマ定義
- デフォルトデータの具体化
- **所要時間**: 1時間相当

#### Phase 4: UI/UX詳細仕様の作成
- ワイヤーフレーム
- コンポーネント設計
- デザインシステム詳細
- **所要時間**: 2-3時間相当

#### Phase 5: 機能詳細仕様の作成
- 各機能の実装仕様
- 状態遷移図
- エラーハンドリング
- **所要時間**: 2-3時間相当

#### Phase 6: テスト戦略とデプロイメントの作成
- テストケース定義
- ビルド設定
- デプロイメント手順
- **所要時間**: 1時間相当

#### Phase 7: レビューと最終化
- 整合性チェック
- 抜け漏れ確認
- **所要時間**: 1時間相当

### 9.2 マイルストーン

| フェーズ | 成果物 | 状態 |
|---------|--------|------|
| Phase 1 | 確認事項への回答 | 🔴 未着手 |
| Phase 2 | 技術設計セクション | 🔴 未着手 |
| Phase 3 | データモデル仕様 | 🔴 未着手 |
| Phase 4 | UI/UX詳細仕様 | 🔴 未着手 |
| Phase 5 | 機能詳細仕様 | 🔴 未着手 |
| Phase 6 | テスト&デプロイ仕様 | 🔴 未着手 |
| Phase 7 | 最終レビュー | 🔴 未着手 |

---

## 10. 次のアクション

### 10.1 ユーザーへの確認依頼

**セクション8「確認事項・未決定項目」**の質問に回答いただくことで、機能仕様書の作成を開始できます。

特に重要な確認事項：
1. 🔴 **デフォルトプリセットの具体的ブラインド構造**（8.1）
2. 🔴 **音声通知のタイミングと種類**（8.2）
3. 🟡 **休憩設定のデフォルト値**（8.3）
4. 🟡 **レベル時間のデフォルト値**（8.4）
5. 🟢 **その他の細かい仕様**（8.5-8.12）

### 10.2 作業開始の条件

以下が揃えば機能仕様書の作成を開始可能：
- [ ] 確認事項（🔴重要）への回答
- [ ] 確認事項（🟡中程度）への回答（または「お任せ」の指示）
- [ ] 技術スタック（React + TS + Vite）の最終承認

---

## 11. 補足事項

### 11.1 設計原則

機能仕様書作成にあたり、以下の原則を遵守します：

1. **YAGNI**: 将来的な拡張は仕様に含めない
2. **KISS**: シンプルな設計を優先
3. **実装可能性**: 開発者がすぐ実装できる具体性
4. **一貫性**: 要求仕様書との整合性を保つ
5. **拡張性**: 優先度：中の機能追加を想定した設計

### 11.2 想定される読者

機能仕様書の想定読者：
- フロントエンド開発者（React/TypeScript経験者）
- システムアーキテクト
- QAエンジニア
- プロダクトオーナー（レビュー時）

### 11.3 参考資料

機能仕様書作成時に参考にする資料：
- 要求仕様書（docs/urs/requirements.md v1.1）
- React公式ドキュメント
- TypeScript公式ドキュメント
- Web Audio API仕様
- Fullscreen API仕様
- localStorage仕様

---

## 改訂履歴

| バージョン | 日付 | 変更内容 | 作成者 |
|-----------|------|---------|--------|
| 1.0 | 2026-01-24 | 初版作成 | AI System Architect |

---

## Appendix: 技術選定の詳細理由

### A.1 React + TypeScript を選ぶ理由

1. **型安全性**: ドメインモデルの厳密な定義が可能
2. **開発速度**: 豊富なライブラリとツール
3. **保守性**: コンポーネント単位での理解とメンテナンスが容易
4. **拡張性**: 優先度：中の機能追加時に対応しやすい
5. **コミュニティ**: 問題解決のための情報が豊富

### A.2 Vite を選ぶ理由

1. **高速**: HMRが非常に速い
2. **軽量**: 設定がシンプル
3. **現代的**: ES Modules ネイティブサポート
4. **最適化**: プロダクションビルドが効率的

### A.3 状態管理に Context + useReducer を選ぶ理由

1. **依存なし**: 追加ライブラリ不要
2. **十分な機能**: このプロジェクトの複雑度には十分
3. **学習コスト**: React開発者には馴染みがある
4. **型安全**: TypeScriptとの親和性が高い

---

**本計画書に基づき、確認事項への回答後、機能仕様書の作成を開始します。**
